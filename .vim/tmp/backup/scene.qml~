import QtQuick 2.0 
import "./Handy" 


Rectangle{
    width : 900  
    height: width 
    color : "lightblue"  

    Mur{
        id: mur1 
        _x : parent.width / 2 
        _y  : parent.height / 2 
        mur_hauteur : 200 
        focus : true
    }




    Mur{
        id: mur2 
        _x : mur1._x -400    
        _y  : mur1._y  
        mur_hauteur : 200 
        focus : true
    }


    Mur{
       id : mur4 //Porte 
       _x :mur1._x +  Math.sin(mur1.angle1)*( mur1._x/2 - mur_kante/2)
       _y :mur1._y +mur_hauteur -  Math.cos(mur1.angle1)*( mur1._x/2- mur_kante/2) 
       mur_kante   : 150 
       mur_hauteur : 100 
        focus : true
    }

    Canvas{
        id : canvas 
        anchors.fill : parent 
        onPaint: {
            var ctx = canvas.getContext('2d') 
            //Maur streichen 
            ctx.save()
            ctx.beginPath()
            ctx.lineWidth = 10 
            ctx.strokeStyle = "grey"
            var i = false; 
            var counter = 0; 

            while( !i )
            {

                counter += 60; 
                ctx.moveTo( mur1._x - counter , mur1._y + mur1.mur_hauteur)

                if( counter == 60 )
                {
                    ctx.lineTo( mur1._x - counter + 115*Math.sin(0.52333),     
                    mur1._y + mur1.mur_hauteur -    115*Math.cos(0.52333) ) 
                }
                else 
                {
                    ctx.lineTo( mur1._x - counter + mur1.mur_kante*Math.sin(0.52333),     
                    mur1._y + mur1.mur_hauteur - mur1.mur_kante*Math.cos(0.52333) ) 
                }
                ctx.stroke()
                if( counter>= 360 )
                i = true; 
            }
            ctx.closePath()
            ctx.restore()


            ctx.save()
            ctx.beginPath()
            ctx.lineWidth = 10 
            ctx.strokeStyle = "grey"
             i = false; 
             counter = 0; 

            while( !i )
            {
                counter += 50; 
            

                ctx.moveTo(  mur2._x + mur2.mur_width+ counter*Math.sin(0.52333) ,
                mur2._y + mur2.mur_hauteur - counter*Math.cos(0.52333))

                if( counter <= 200 )
                {
                    ctx.lineTo( mur1._x + counter*Math.sin(0.52333) - counter*Math.atan(0.52333)-2 , 
                    mur1._y + mur1.mur_hauteur - counter*Math.cos(0.52333) ) 
                }
                else if( counter == 250 )
                {
                    ctx.lineTo( mur1._x + counter*Math.sin(0.52333) - counter*Math.atan(0.52333)-2 , 
                    mur1._y + mur1.mur_hauteur - counter*Math.cos(0.52333) ) 
                
                }
                else if( counter == 300 ) 
                {
                    ctx.lineTo( mur1._x + counter*Math.sin(0.52333) - counter*Math.atan(0.52333)-2 +24, 
                    mur1._y + mur1.mur_hauteur - counter*Math.cos(0.52333) ) 
                
                }
                else 
                {
                    ctx.lineTo( mur1._x + counter*Math.sin(0.52333) - counter*Math.atan(0.52333)-2 +50, 
                    mur1._y + mur1.mur_hauteur - counter*Math.cos(0.52333) ) 
                
                }
                ctx.stroke()
                if( counter> 300 )
                i = true; 
            }
            ctx.closePath()
            ctx.restore()

            // hintergrund 
            ctx.beginPath()
            ctx.lineWidth = 2  
            ctx.strokeStyle = "black"
            ctx.moveTo( mur2._x1 + mur2.mur_width , mur2._y1 +2  )
            ctx.lineTo( mur1._x1 , mur1._y1 +2   )
            ctx.stroke() 
            ctx.closePath()
            //weiter mit hintergrund 
            ctx.beginPath()
            ctx.lineWidth = 2  
            ctx.strokeStyle = "black"
            ctx.moveTo( mur2._x1 + mur2.mur_width , mur2._y1 + mur2.mur_hauteur  )
            ctx.lineTo( mur1._x1 - 116 , mur1._y1 +mur1.mur_hauteur )
            ctx.stroke() 
            ctx.closePath()
            // vordergrund  
            ctx.beginPath()
            ctx.lineWidth = 2  
            ctx.strokeStyle = "black"
            ctx.moveTo( mur2._x + mur2.mur_width , mur2._y +2  )
            ctx.lineTo( mur1._x , mur1._y +2   )
            ctx.stroke() 
            ctx.closePath()

            //vordergrund bis 
            ctx.beginPath()
            ctx.lineWidth = 2  
            ctx.strokeStyle = "black"
            ctx.moveTo( mur2._x + mur2.mur_width , mur2._y + mur2.mur_hauteur -2 )
            ctx.lineTo( mur1._x  , mur1._y +mur1.mur_hauteur-2 )
            ctx.stroke() 
            ctx.closePath()


            drawKante( ctx , mur1._x , mur1._y ,mur1.mur_kante ,0.52333 )
            drawKante( ctx , mur1._x+mur1.mur_width ,mur1._y,400,0.52333 )
            drawKante( ctx ,mur1._x,mur1._y + mur1.mur_hauteur,400, 0.52333)
            drawKante( ctx , mur1._x+mur1.mur_width, mur1._y + mur1.mur_hauteur,400, 0.52333)

            drawKante( ctx , mur2._x , mur2._y ,mur2.mur_kante ,0.52333 )
            drawKante( ctx , mur2._x  +mur2.mur_width ,mur2._y,400,0.52333 )
            drawKante( ctx , mur2._x  ,mur2._y + mur2.mur_hauteur,400, 0.52333)
            drawKante( ctx , mur2._x  +mur2.mur_width, mur2._y + mur2.mur_hauteur,400, 0.52333)


            drawKante( ctx , mur4._x , mur4._y ,mur4.mur_kante ,0.52333 )
            drawKante( ctx , mur4._x  +mur4.mur_width ,mur4._y,mur4.mur_kante ,0.52333 )
            drawKante( ctx , mur4._x  ,mur4._y + mur4.mur_hauteur,mur4.mur_kante, 0.52333)
            drawKante( ctx , mur4._x  +mur4.mur_width, mur4._y + mur4.mur_hauteur,mur4.mur_kante, 0.52333)

            //Draw Road 
            ctx.beginPath()
            ctx.moveTo(  mur4._x + mur4.mur_width , mur4._y + mur4.mur_hauteur )
            ctx.lineTo( mur4._x  + mur4.mur_width+ 350 , mur4._y + mur4.mur_hauteur )
            ctx.moveTo(  mur4._x1 + mur4.mur_width , mur4._y1 + mur4.mur_hauteur )
            ctx.lineTo( mur4._x1  + mur4.mur_width+ 300 , mur4._y1 + mur4.mur_hauteur )
            ctx.strokeStyle = "black"
            ctx.stroke()
            ctx.closePath()


            painMur( ctx, mur1._x + mur1.mur_width, mur1._y , mur1.mur_hauteur, mur1.mur_kante,30, "red" )
            painMur( ctx, mur4._x + mur4.mur_width, mur4._y , mur4.mur_hauteur, mur4.mur_kante,30, "lightblue" ) 
            painMur( ctx, mur2._x + mur2.mur_width, mur2._y+3 , mur2.mur_hauteur, 400-mur2.mur_width ,0, "red" )  
            painMur( ctx, mur2._x + mur2.mur_width, mur2._y , mur2.mur_hauteur-4, mur2.mur_kante ,30, "red" )

        }//end of onpaint 
   
}//end of canvas 

function drawKante( ctx, corner_x , corner_y , kante, angle1 )
{
    ctx.save()
    ctx.beginPath()
    ctx.moveTo( corner_x, corner_y )
    ctx.lineTo( corner_x + kante*Math.sin(angle1) ,corner_y - kante*Math.cos(angle1))
    ctx.strokeStyle = "black"
    ctx.lineWidth = 2 
    ctx.stroke()
    ctx.restore()
}

function painMur(ctx, xoff_, yoff_, hauteur, kante, angle1, col ) {

    if( angle1 != 0 )
    var radangle =   2*3.14*angle1 / 360 
    var x = 0; 
    var y = 0; 

    ctx.save()
       for(var i = 0; i < kante ; i++ ) 
       {
            if( angle1 ==0)
            {
                x = i + xoff_  
                y = yoff_  
            }
            else
            {
                x =  i * Math.sin(radangle) + xoff_ 
                y = yoff_ - i * Math.cos(radangle)
            }
           for( var j = y ; j< y + hauteur; j++)
           {
               ctx.beginPath()
               ctx.fillStyle = col 
               ctx.fillRect(x , j,2 , 2)
               ctx.fill()
               ctx.closePath()
           }
            
       }
    ctx.restore()
}//enf of function painMur 



    focus: true 
        Person{
            id : animation 
            _x: mur4._x + 300   
            _y:  mur4._y - 40      
            focus : false 
        }

        ReedSensor{
            id : reedSensor
            x:mur4._x +Math.sin(0.52333)
            y: mur4._y -60-height   - Math.cos(0.52333 )
            width : 100 
            height: 50 
            color: "black"
            /*rotation : -30 */
            rotation: 120  
        }


    Keys.onRightPressed:{

       if( animation._x == 839 )
       {
            animation._x = 839 
             
       }
       else
       {
            animation._x =animation._x + 5
            animation.x = animation._x 
       }
       reedSensor.x_eingang = animation._x 
       reedSensor.x_ausgang = animation._x 
       animation.state = "recht"
       console.log("x", animation._x );
       console.log("y", animation._y ); 

       if( animation._x == 394 )
       {
           animation.opacity = 0.0
       }

       if( animation._x == 544 )
       {
        animation.opacity = 1 
       }

    }

    Keys.onLeftPressed:{
       if( animation._x == 214 )
       {
            animation._x = 214 
       }
       else
       {
            animation._x =animation._x - 5
            animation.x = animation._x 
       }
       reedSensor.x_ausgang = animation._x 
       reedSensor.x_eingang = animation._x 
        animation.state = "left" 
        console.log("x",animation._x);
        console.log("y", animation._y );   


       if( animation._x == 544)
       {
           animation.opacity = 0.0
       }

       if( animation._x == 394 )
       {
        animation.opacity = 1 
       }

    }

    Keys.onUpPressed : {
       if( animation._y == 240 )
       {
            animation._y = 240; 
       }
       else
       {
        animation._y =animation._y - 5
        animation.y = animation._y 
       }
    }

    Keys.onDownPressed:{

        if( animation._y == 375 )
        {
            animation._y = 375; 
        }
        else
        {
            animation._y =animation._y + 5 
            animation.y = animation._y 
        }
        console.log("Downx",animation._x);
        console.log("Downy", animation._y );   
    }

    Thermometer{
        width: 200 
        height: 200 

        x: 300 
        y: 105
        }

        Handy{
            x: 500 
            y: 20
            height: 100 
        }

}//end of Rectangle 
