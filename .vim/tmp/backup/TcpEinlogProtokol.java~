package de.hs_mannheim.server;

import de.hs_mannheim.ErrorHandling.TcpErrorMessage;
import de.hs_mannheim.model.*;


import java.io.InputStream;
import java.io.OutputStream;

public class TcpEinlogProtokol {
	
	boolean debug = false; 
	SRN_EinlogModel modell;
	
	InputStream in; 
	OutputStream out; 
	Emission emission; 
	Reception reception; 
		
	public 
	TcpEinlogProtokol(InputStream in, OutputStream out  ) {
		
		this.in = in; 
		this.out = out; 
		emission = new Emission(this.out);
		reception = new Reception(this.in);
		
	}
	
	public void setModell( SRN_EinlogModel modell)
	{
		this.modell = modell; 
	}
	
	
	/*
	 * Send Command to the Server to tell wich Action 
	 * the Client want to execute. 
	 * If the Server Send back the Same Action. That 
	 * Mean the process can start . Otherwise the Connection 
	 * will be brake and the process finish. 
	 * */
	boolean 
	firstAction()
	{
		
		Object received_obj = reception.readObject();
		
		/*
		 * just a lazy way to make sure the Server already have 
		 * the Data to send to the Client. 
		 * */
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		/**** End of the Laziness ;) ****/
		
		if( received_obj.toString().contains( 
				de.hs_mannheim.konstante.Ui_Kommand.tcp_send_einlog_command_to_server))
		{
			System.out.println( "1. Sever "+ received_obj.toString());

			emission.sendObject(new String(
					de.hs_mannheim.konstante.Ui_Kommand.tcp_send_einlog_command_to_server			
						));
			return debug = true; 
		}
		else 
		{
			System.out.println( "1. Sever didnt receive good Command " + "False \n");
			return false; 
		}
	}
	
	/*
	 * Send the EinlogModell to Server . 
	 * if the Server send-back null , 
	 * we go to the next Action . 
	 * if the Server send-back a Exception-Object 
	 * the connection will be brake and the process finish. 
	 * */
	boolean 
	secondAction()
	{
		
		
		Object obj = reception.readObject(); 
		Object response = null; 
		
		System.out.println( 
				"SERVER REceive : \n " + 
				obj.toString()
				); 
		
		
		/*
		 * Another Laziness for the same Reason as above 
		 * */
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		/**** End of another Laziness ;) ****/
		
		if ( obj == null )
		{
			response = new TcpErrorMessage();
			emission.sendObject(response);
			return false; 
		}
		else
		{
			emission.sendObject(response); 
			return debug = true;
		}
	}
	
	
	/*
	 * 
	 * Waiting for Server Response. Because at this
	 * stage the Server will process the DataBase 
	 * with the Data that have been send at stage 2. 
	 * For Identification Purpose the Server will 
	 * Send-back an TcpErrorMessage if the Identification 
	 * has failed. otherwise , a bunch of DataModell object 
	 * whith the User Informations. 
	 * 
	 * */
	boolean
	thirdAction()
	{
		//Process DABASE 
		//And send Gui Data to Client 
		return debug = true; 
		
	}
	
	/*
	 * Yeahhhhhhh the last Action ;) 
	 * Depending on the Result of the 3. Action 
	 * the Last action will process :  
	 * -> if "true" Displaying the Main UI and feed 
	 *    the last ui with Data. 
	 * -> if "false" returning to the Einlog UI . 
	 * 
	 * The connection will be close the the both Cases. 
	 * With in.close(); 
	 * */
	boolean 
	lastAction()
	{
	    System.out.println("display MainUI and Close Connection"); 
	    return debug = true; 
	}
	
	
	
	public boolean process()
	{
		if( firstAction() )
		{	if(secondAction())
			{	if(thirdAction())
				{	if( lastAction() )
					{
						
					}else{	debug = false; }
				}else{ debug = false;} 
			}else{ debug = false; } 
		}else{ debug = false; } 
		
		return debug; 
	}
	
	

}//End of the class 
